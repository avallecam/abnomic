---
title: "REPRODUCCIÓN: K.Torres Pf asymptomatic"
author: "Andree Valle Campos"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
  #html_notebook:
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
    #theme: united
    code_folding: "hide"
    #fig_caption: TRUE
    #number_sections: TRUE
#bibliography: malaria.bib
#csl: american-medical-association.csl
---

# Setup 
```{r setup0, results='hide', message=FALSE}
#require(Hmisc)
#require(plotly)
options(#grType='plotly',  # for certain graphics functions
        width = 110) # to expand the limits of CONSOLE output
#mu <- markupSpecs$html   # markupSpecs is in Hmisc

# The following hidden command (<code>r mu$widescreen()</code>), causes the html notebook to use an entire wide screen.
#mu$widescreen()
```

 
# Dependencies

This document has the following dependencies:
```{r dependencies, warning=FALSE, message=FALSE}
library("Biobase")     #ExpressionSet
library("genefilter")  #DataCondensation
library("limma")       #DifferentialAnalysisOfGenes
#library("gplots")      #Heatmaps!
library("NMF")         #AnnotatedHeatmaps!!!

#library("haven")

#library(beeswarm)
#library(vioplot)
#library(beanplot)
#library(HSAUR3)

#library("stargazer")

#library(dplyr)        #mutate
library(ggplot2)      #ggplot for VolcanoPlots
#library(ggrepel)      #names2dots #devtools::install_github("slowkow/ggrepel")
library(Rmisc)        #multiploting ggplots

#library("htmlTable")  #HTMLtables -minimalistic- without 'ResultsAsis'
#library(knitr)        #better it seems

#library(tidyr)        #Gather "extend" two point data
#library(dplyr)

#library(broom)        #Tidy Hipothesis testing and LinearRegression outputs
#library(biobroom)
```

***

# Microarray Data Analysis

# 1. Data Tidying

## Data input

```{r organaize}
#getwd()
###### [IMPORT DATA]
raw<-read.csv("TORRES_ProtMicroarray.csv")
```


```{r organize2}
#
## MAKE A MATRIX of all the RAW DATA
#
all.raw_rnames <- raw[,2]                            # assign labels in column 1 to "rnames"
all.raw_data <- data.matrix(raw[,3:ncol(raw)])      # transform column into a matrix
rownames(all.raw_data) <- all.raw_rnames                 # assign row names 
```


```{r organize}
## organized RAW data.set
## subsetting per spot.type
ctrl.raw_rnames <- raw[1:31,2]                            # assign labels in column 1 to "rnames"
ctrl.raw_data <- data.matrix(raw[1:31,3:ncol(raw)])      # transform column into a matrix
rownames(ctrl.raw_data) <- ctrl.raw_rnames                 # assign row names 

## dim(ctrl.raw_data)

median.ctrl.raw_data<-t(as.matrix(apply(ctrl.raw_data, 2, median)))
rownames(median.ctrl.raw_data) <- c("median.ctrl")                 # assign row names 

anti.raw_rnames <- raw[32:nrow(raw),2]                            # assign labels in column 1 to "rnames"
anti.raw_data <- data.matrix(raw[32:nrow(raw),3:ncol(raw)])      # transform column into a matrix
rownames(anti.raw_data) <- anti.raw_rnames                 # assign row names 

## dim(median.ctrl.raw_data)
## dim(anti.raw_data)

########################### MATRIX OF CTRL VALUES
median.ctrl.raw_data.1<-rep(median.ctrl.raw_data[1],nrow(anti.raw_data))
median.ctrl.raw_data.mat<-matrix(median.ctrl.raw_data.1,length(median.ctrl.raw_data.1),1)

for (i in 2:ncol(median.ctrl.raw_data)) {
  median.ctrl.raw_data.mat<-cbind(median.ctrl.raw_data.mat,rep(median.ctrl.raw_data[i],nrow(anti.raw_data)))
}

## dim(median.ctrl.raw_data.mat)

#head(anti.raw_data)[,1:5]
#head(ctrl.raw_data)[,1:5]
#median.ctrl.raw_data[,1:5]
#head(median.ctrl.raw_data.mat)[,1:5]
```


## Data Transformation 
**(a.k.a. FOC normalization)**[@King2015FOC]

```{r norma}
### logic removal of 0 and negative values
log2.zero = function(x) {log2(ifelse(x>0, x, 1))}
log2.NA = function(x) {log2(ifelse(x>0, x, NA))}    ## REQUIRED confirmation with ADI team --> modifies data dsitribution

# [06jul2016] [not present in IqMdD] 
# to choose which operation would be better, evaluate for -Inf, zero or negative values on the ratio
xxx<-anti.raw_data/median.ctrl.raw_data.mat<0 # [06jul2016] only 4
sum(xxx)
#xxx<-anti.raw_data/median.ctrl.raw_data.mat==0 # [06jul2016] non
#sum(xxx)
#sum(is.infinite(anti.raw_data/median.ctrl.raw_data.mat),na.rm = TRUE) # non
```

```{r norma2}
## with log2.NA do not have NaN!!-----------------------------------------------------> THIS IS USED!
log2.NA.norm.ANTIGENS<-log2.NA(anti.raw_data/median.ctrl.raw_data.mat)
## head(log2.NA.norm.ANTIGENS)


```

```{r norma3}
# [VERIFICATION] COUNT NUMBER OF Inf or NaN (09jun2016)
#sum(is.infinite(log2.NA.norm.ANTIGENS),na.rm = TRUE) #0
#sum(is.nan(log2.NA.norm.ANTIGENS),na.rm = TRUE) #0

```

## Data Normalization: Median centering 
**(I/O) ON**

```{r norma4}

###### ***** Median Centering *****

# ¡¡¡ SWEEP !!! --> SIMPLEST NORMALIZATION: Align all log signal to have the same median (median= zero)
# reference: https://www.google.com.pe/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwiM3Y6lsuTMAhWK5yYKHR3GC8oQFggcMAA&url=http%3A%2F%2Fwww.public.iastate.edu%2F~dnett%2Fmicroarray%2F05normalization2color.ppt&usg=AFQjCNF6AMXXJl2GjsdX6uiTS7AFOsbrWg&bvm=bv.122129774,d.eWE

median.NA = function(x) {median(x,na.rm = TRUE)} # REMOVING NA FROM median() FUNCTION

# MEDIAN CENTERING!!
sample.medians <- apply(log2.NA.norm.ANTIGENS, 2, median.NA)
normalized.log2.NA.norm.ANTIGENS <- sweep(log2.NA.norm.ANTIGENS,2,sample.medians) # MEDIAN CENTERED log2.NA.norm.ANTIGENS
#
head(normalized.log2.NA.norm.ANTIGENS)[,1:5]

```

```{r after6, eval=FALSE}

# **** [21jul2016] [CRITICAL modification] ****
normalized.log2.NA.norm.ANTIGENS["PVX_111175.544","LIM2017"] <- 0      ## deliberate modification. 
# REASON: value equals 21 in raw[525,"LIM2017"] and -9.333741 in log2.NA.norm.ANTIGENS["PVX_111175.544","LIM2017"], which is an extreme lower value



#### STEP 1 RESULTS ----> [30jun2016 - UPDATE]
#log2.NA.norm.ANTIGENS            ## NO median centered
#normalized.log2.NA.norm.ANTIGENS ## MEDIAN CENTERING GOES AFTER FILTERING ? --> YES!!! ---> [30jun2016] THIS SHOULD NOT BE USED ---> INSTEAD, scale by heatmap!!!

## [URGENT UPDATE] 
## [30jun2016] THIS SHOULD NOT BE USED ---> INSTEAD, scale by heatmap!!!


# THEN MODIFIED: we are not going to use median centered normalization, instead, heatmap.2 Z-SCORE is going to be used

# **** [06jul2016] [CRITICAL EVALUATION]
#normalized.log2.NA.norm.ANTIGENS <- log2.NA.norm.ANTIGENS 

##########################################################

```

```{r eset}

# COPIED and adapted...........................................................................#
normal.log2.raw.eSet<-ExpressionSet(assayData = normalized.log2.NA.norm.ANTIGENS)#,
                                    #phenoData = phenoDataN6,
                                    #featureData = featureDataN6.IVTT.AG)                        ## still missing FEATURE DATA (SEPARATE Pfal vs Pviv)!!!!
```

```{r cond, echo=TRUE}
#
#normal.log2.raw.eSet             # 1014 features X 40 samples   (10%= 4)
#
#normal.log2.raw.eSet.VIVAX.PQ    # 515 features X 140 samples    (10%= 14)
#normal.log2.raw.eSet.FALCIP.PQ   # 499 features X 140 samples    (10%= 14)
#normal.log2.raw.eSet.VIVAX.SEV   # 515 features X 60 samples     (10%= 6)
#normal.log2.raw.eSet.FALCIP.SEV  # 499 features X 60 samples     (10%= 6)
#
############################## [START] GENEFILTER for each DATASET (n=4)
f1 <- kOverA(4,1)                           ## expression measure above 1 in at least 20 samples
ffun <- filterfun(f1)
wh1 <- genefilter(exprs(normal.log2.raw.eSet),ffun)  # WHOLE data set
sum(wh1) # 588 -> 352 ---------------------------------------------------->>>> (ALL of this are WITHOUT mean centering)
#
# GENERATE the NEW ExpressionSet
normal.log2.raw.eSet.FILTER<-normal.log2.raw.eSet[wh1,]
normal.log2.raw.eSet.FILTER

##############################

```

# X. QC Graphics 
raw -> log2 -> median centering -> filtered

## whole dataset
```{r quality1PNG, eval=FALSE, echo=FALSE}
##### [cool merge pre and post normalization - start]     [EXTRA COOL!!!!!!!!]
png("raw_norm_med_FILT_DENSITIES.png",    # create PNG for the heat map        
    width = 6000,
    height = 5000,        # DIMENSIONS of final image: 1500x1500 pixels
    res = 300,            # 300 pixels per inch (RESOLUTION)
    pointsize = 8)        # smaller font size
##

#
dev.off()
##
```

```{r quality1, fig.height=15, fig.width=20}

colours = hsv(seq(0,1,length=200),0.6,1)                 ## CLEARIFY THIS FUNCTION

par(mfrow=c(3,4))
#par(mfcol=c(4,3))
#
plotDensities(all.raw_data, legend = FALSE, main = "N6 Raw Intensity")
plotDensities(log2.NA.norm.ANTIGENS, legend = FALSE, main = "N6 Normalized Intensity (only)")
plotDensities(normalized.log2.NA.norm.ANTIGENS, legend = FALSE, main = "N6 Normalized + Median Centering")
plotDensities(exprs(normal.log2.raw.eSet.FILTER), legend = FALSE, main = "AFTER FILTERING")
#
hist(all.raw_data,breaks=600, col = "black", main = NULL, ylim = c(0,2500))
hist(log2.NA.norm.ANTIGENS,breaks=600, col = "black", main = NULL, ylim = c(0,2500))
hist(normalized.log2.NA.norm.ANTIGENS,breaks=600, col = "black", main = NULL, ylim = c(0,2500))
hist(exprs(normal.log2.raw.eSet.FILTER),breaks=600, col = "black", main = NULL, ylim = c(0,2500))           # THIS IS IT!!
#
boxplot(all.raw_data,col=colours,pch=20, las=2, 
        ylab="Untransformed intensity")
boxplot(log2.NA.norm.ANTIGENS,col=colours,                 #JUST log2 NORMALIZATION
        pch=20, ylim=c(-3,6.3),
        las=2, 
        ylab="LOG2 intensity")
boxplot(normalized.log2.NA.norm.ANTIGENS,col=colours,      #sweep --> MEDIAN CENTERING
        pch=20, ylim=c(-3,6.3),
        las=2, 
        ylab="LOG2 intensity")                # ¿check this? SINCE output of negative values turns to NA, median gets NULL
boxplot(exprs(normal.log2.raw.eSet.FILTER),col=colours,
        pch=20, ylim=c(-3,6.3),
        las=2, 
        ylab="LOG2 intensity")                             # REQUIRED!!

##### [cool merge pre and post normalization - end]

```


```{r qualityX}
########################### SAMPLE ORDER per group

# [START FROM THE BEGINNNING]
eset<-normal.log2.raw.eSet
#eset$Group <- factor(eset$Group)
#eset$Group

#pData(eset) <- cbind(pData(eset),cat_2,t(col.mean.m_dataX))#ncol(pData(eset))
#rownames(sampleSEVcovariates)
#cat_2 <- data.frame(as.factor(matrix(sampleSEVcovariates$edad_CAT)))
#rownames(cat_2) <- rownames(sampleSEVcovariates)
#colnames(cat_2) <- "edad_CAT_2"
#pData(eset)[23] <- sampleSEVcovariates$edad_CAT
#pData(eset) <- cbind(pData(eset),cat_2)#ncol(pData(eset))

# starts
#class(exprs(eset)) #matrix
m_data <- exprs(eset)
m_data<-as.data.frame(m_data)

# [MODIFICATION 28jul2016]
col.mean.m_dataX<-t(as.matrix(apply(m_data, 2, mean, na.rm=TRUE)))
rownames(col.mean.m_dataX) <- c("col.mean.m")                 # assign row names 
#col.mean.m_dataX

row.mean.m_data<-as.matrix(apply(m_data, 1, mean, na.rm=TRUE))
colnames(row.mean.m_data) <- c("row.mean.m")                 # assign row names 
#row.mean.m_data


m_data_row.mean<-cbind(m_data,row.mean.m_data)
m_data_row.mean<-as.matrix(m_data_row.mean)

m_data_row.mean<-as.data.frame(m_data_row.mean)
m_data_row.mean<-m_data_row.mean[order(-m_data_row.mean$row.mean.m),]
m_data_row.mean<-as.matrix(m_data_row.mean)

m_data_row.mean<-as.data.frame(m_data_row.mean)
m_data_row.mean$row.mean.m<-NULL
#dim(m_data_row.mean)
#m_data_row.mean
m_data_row.mean<-as.matrix(m_data_row.mean)
#

m_data_col.row.mean<-rbind(m_data_row.mean,col.mean.m_dataX)

m_data_col.row.mean<-t(m_data_col.row.mean)
m_data_col.row.mean<-as.data.frame(m_data_col.row.mean)

m_data_col.row.mean<-m_data_col.row.mean[order(m_data_col.row.mean$col.mean.m),]
m_data_col.row.mean$col.mean.m<-NULL
m_data_col.row.mean<-t(m_data_col.row.mean)

m_data_col.row.mean<-as.data.frame(m_data_col.row.mean)
#dim(m_data_col.row.mean)
#m_data_col.row.mean
m_data_col.row.mean<-as.matrix(m_data_col.row.mean)
# ends


##### TOP10 OF HIGHER REACTIVITY in BOTH GROUPS -> the same as sort.by AveExp
#head(rownames(m_data_col.row.mean), 10)

# [ADDED 28jul2016]
feature_sort_mean<-rownames(m_data_col.row.mean)
sample_sort_mean_FIRST<-colnames(m_data_col.row.mean)
#
pData(eset) <- cbind(pData(eset),t(col.mean.m_dataX))#ncol(pData(eset))
#
eset <- eset[feature_sort_mean,sample_sort_mean_FIRST] ## REORDER samples and features inside the ExpressionSet

#eset$Group
```


```{r heatmap11, eval=TRUE}
#head(anti.raw_data)[,1:5]
#head(log2.NA.norm.ANTIGENS)[,1:5]
#head(exprs(normal.log2.raw.eSet.VIVAX.SEV.FILTER))[,1:5]

rawhm <- anti.raw_data[feature_sort_mean,sample_sort_mean_FIRST] ## REORDER samples and features inside the ExpressionSet
#head(rawhm)[,1:5]

#log2hp <- exprs(normal.log2.raw.eSet.VIVAX.SEV.FILTER)[feature_sort_mean,sample_sort_mean_FIRST] ## REORDER samples and features inside the ExpressionSet
#sum(log2hp==exprs(eset))
#head(log2hp)[,1:5]
#head(exprs(eset))[,1:5]

ctrlhm <- ctrl.raw_data[,sample_sort_mean_FIRST] ## REORDER samples and features inside the ExpressionSet
#head(ctrlhm)[,1:5]

#head(median.ctrl.raw_data)[,1:5]
#median.ctrl.raw_data
```


```{r heatmap10, fig.height=8, fig.width=8, fig.align="center", eval=FALSE, echo=FALSE}
#**`gplots` package** [@gplots]
#
color.map <- function(Group) { if (Group=="D") "#ff0000" else "#00ffff" }   # GROUP D is RED!!!!
patientcolors.SEV <- unlist(lapply(eset$Group, color.map))
#table(patientcolors.SEV)
#
##### THIS IS THE RIGHT HEATMAP (with unordered groups)
heatmap.2(exprs(eset), 
          
          Rowv = FALSE,
          Colv = FALSE,
          dendrogram = "none",
          
          col=bluered(10), 
          scale = "none", 
          ColSideColors = patientcolors.SEV, 
          key = TRUE, symkey = FALSE,
          density.info = "histogram", denscol = "black", 
          trace = "none", cexRow = 0.5)

par(lend = 1)           # square line ends for the color legend
legend("topright",      # location of the legend on the heatmap plot
    legend = c("Severe", "Non-severe"), # category labels
    col = c("#ff0000", "#00ffff"),  # color key
    lty= 1,             # line style
    lwd = 10            # line width
)
#
```

**using `NMF` package** [@Gaujoux2010NMF]

#### By Mean Sample Intensity
```{r heatmap0, eval=TRUE, fig.height=8, fig.width=8, fig.align="center"}
#eset<-normal.log2.raw.eSet.VIVAX.SEV.FILTER
#pData(eset) <- pData(eset)[,9:ncol(pData(eset))]
#library(NMF)
aheatmap(exprs(eset), Rowv = NA, Colv = NA, annCol = pData(eset))
```


### Backgroud effect
```{r bckgrd1, fig.height=8, fig.width=8, fig.align='center', warning=FALSE, message=FALSE}
#rownames(row.mean.m_data)
RAW_data <- anti.raw_data[rownames(row.mean.m_data),]
row.mean.RAW_data<-as.matrix(apply(RAW_data, 1, median, na.rm=TRUE))
colnames(row.mean.RAW_data) <- c("row.mean.RAW")                 # assign row names 
#
col.mean.RAW_data<-as.matrix(apply(RAW_data[,colnames(col.mean.m_dataX)], 2, median, na.rm=TRUE)) ### ONLY FOR 60 samples
colnames(col.mean.RAW_data) <- c("col.mean.RAW")                 # assign row names 
#
#head(row.mean.RAW_data)
#head(row.mean.m_data)
totint <- cbind(row.mean.m_data,row.mean.RAW_data)
totint <- as.data.frame(totint)
colnames(totint) <- c("LOG2.feature.mean.int", "RAW.feature.median.int")
t1 <- ggplot(totint, aes(x=LOG2.feature.mean.int,y=RAW.feature.median.int)) + geom_point() + geom_smooth()
#
sampleint <- cbind(t(col.mean.m_dataX),col.mean.RAW_data)
sampleint <- as.data.frame(sampleint)
colnames(sampleint) <- c("LOG2.sample.mean.int", "RAW.sample.median.int")
t2 <- ggplot(sampleint, aes(x=LOG2.sample.mean.int,y=RAW.sample.median.int)) + geom_point() + geom_smooth()
#
#class(col.mean.m_dataX)
#class(median.ctrl.raw_data)
No.DNA.int <- subset(median.ctrl.raw_data, select= colnames(col.mean.m_dataX))
#No.DNA.int
#col.mean.m_dataX
back <- rbind(col.mean.m_dataX,No.DNA.int)
back <- as.data.frame(t(back))
colnames(back) <- c("LOG2.sample.mean.int", "RAW.No.DNA.median.int")
b1 <- ggplot(back, aes(x=LOG2.sample.mean.int,y=RAW.No.DNA.median.int)) + geom_point() + geom_smooth()
#
rawk <- cbind(col.mean.RAW_data,t(No.DNA.int))
rawk <- as.data.frame(rawk)
colnames(rawk) <- c("RAW.sample.median.int", "RAW.No.DNA.median.int")
b2 <- ggplot(rawk, aes(x=RAW.sample.median.int,y=RAW.No.DNA.median.int)) + geom_point() + geom_smooth()
#
multiplot(t1,b2,t2,b1, cols=2)
#
```

```{r bckgrnd2, fig.width=14, fig.height=7, fig.align='center'}
par(mfrow=c(1,2))

# [START FROM THE BEGINNNING]
eset<-normal.log2.raw.eSet
#
eset <- eset[feature_sort_mean,sample_sort_mean_FIRST] ## REORDER samples and features inside the ExpressionSet

aheatmap(exprs(eset), Rowv = NA, Colv = NA, main = "LOG2")
aheatmap(rbind(rawhm,ctrlhm), Rowv = NA, Colv = NA, main = "RAW")
```


### Heteroskedasticity 
*pre- & post- transformation/normalization*
```{r homosk1, fig.height=4, fig.width=8, fig.align='center', warning=FALSE, message=FALSE}
#
RAW_data <- anti.raw_data[rownames(row.mean.m_data),]
row.sd.RAW_data<-as.matrix(apply(RAW_data, 1, sd, na.rm=TRUE))
colnames(row.sd.RAW_data) <- c("row.mean.RAW")                 # assign row names 
#
homoskRAW <- cbind(row.mean.RAW_data,row.sd.RAW_data)
homoskRAW <- as.data.frame(homoskRAW)
colnames(homoskRAW) <- c("RAW.feature.median.int","RAW.feature.sd.int")
h2 <- ggplot(homoskRAW, aes(x=RAW.feature.median.int,y=RAW.feature.sd.int)) + geom_point() + geom_smooth()
#
row.sd.m_data<-as.matrix(apply(m_data, 1, sd, na.rm=TRUE))
colnames(row.sd.m_data) <- c("row.sd.m")                 # assign row names 
#
homosk <- cbind(row.mean.m_data,row.sd.m_data)
homosk <- as.data.frame(homosk)
colnames(homosk) <- c("LOG2.feature.mean.int", "LOG2.feature.sd.int")
h1 <- ggplot(homosk, aes(x=LOG2.feature.mean.int,y=LOG2.feature.sd.int)) + geom_point() + geom_smooth()#method="lm",se=FALSE
#
multiplot(h2,h1,cols=2)
```
